<?php

declare(strict_types=1);

namespace LegitPHP\HashMoney\Strategies;

use Jcupitt\Vips\Image as VipsImage;
use LegitPHP\HashMoney\HashValue;

class PerceptualHashStrategy extends AbstractHashStrategy
{
    private const ALGORITHM_NAME = 'perceptual';

    private const SIZE_SQRT = 0.25;

    private const DCT_COEFFICIENTS = [
        64 => ['size' => 32, 'matrix_size' => 11],
        32 => ['size' => 24, 'matrix_size' => 9],
        16 => ['size' => 16, 'matrix_size' => 7],
        8 => ['size' => 8, 'matrix_size' => 5],
    ];

    // DCT matrix for 11x32 (used for 64-bit hashes)
    private const DCT_11_32 = [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [0.99879546, 0.98917651, 0.97003125, 0.94154407, 0.90398929, 0.85772861, 0.80320753, 0.74095113, 0.67155895, 0.5956993, 0.51410274, 0.42755509, 0.33688985, 0.24298018, 0.14673047, 0.04906767, -0.04906767, -0.14673047, -0.24298018, -0.33688985, -0.42755509, -0.51410274, -0.5956993, -0.67155895, -0.74095113, -0.80320753, -0.85772861, -0.90398929, -0.94154407, -0.97003125, -0.98917651, -0.99879546],
        [0.99518473, 0.95694034, 0.88192126, 0.77301045, 0.63439328, 0.47139674, 0.29028468, 0.09801714, -0.09801714, -0.29028468, -0.47139674, -0.63439328, -0.77301045, -0.88192126, -0.95694034, -0.99518473, -0.99518473, -0.95694034, -0.88192126, -0.77301045, -0.63439328, -0.47139674, -0.29028468, -0.09801714, 0.09801714, 0.29028468, 0.47139674, 0.63439328, 0.77301045, 0.88192126, 0.95694034, 0.99518473],
        [0.98917651, 0.90398929, 0.74095113, 0.51410274, 0.24298018, -0.04906767, -0.33688985, -0.5956993, -0.80320753, -0.94154407, -0.99879546, -0.97003125, -0.85772861, -0.67155895, -0.42755509, -0.14673047, 0.14673047, 0.42755509, 0.67155895, 0.85772861, 0.97003125, 0.99879546, 0.94154407, 0.80320753, 0.5956993, 0.33688985, 0.04906767, -0.24298018, -0.51410274, -0.74095113, -0.90398929, -0.98917651],
        [0.98078528, 0.83146961, 0.55557023, 0.19509032, -0.19509032, -0.55557023, -0.83146961, -0.98078528, -0.98078528, -0.83146961, -0.55557023, -0.19509032, 0.19509032, 0.55557023, 0.83146961, 0.98078528, 0.98078528, 0.83146961, 0.55557023, 0.19509032, -0.19509032, -0.55557023, -0.83146961, -0.98078528, -0.98078528, -0.83146961, -0.55557023, -0.19509032, 0.19509032, 0.55557023, 0.83146961, 0.98078528],
        [0.97003125, 0.74095113, 0.33688985, -0.14673047, -0.5956993, -0.90398929, -0.99879546, -0.85772861, -0.51410274, -0.04906767, 0.42755509, 0.80320753, 0.98917651, 0.94154407, 0.67155895, 0.24298018, -0.24298018, -0.67155895, -0.94154407, -0.98917651, -0.80320753, -0.42755509, 0.04906767, 0.51410274, 0.85772861, 0.99879546, 0.90398929, 0.5956993, 0.14673047, -0.33688985, -0.74095113, -0.97003125],
        [0.95694034, 0.63439328, 0.09801714, -0.47139674, -0.88192126, -0.99518473, -0.77301045, -0.29028468, 0.29028468, 0.77301045, 0.99518473, 0.88192126, 0.47139674, -0.09801714, -0.63439328, -0.95694034, -0.95694034, -0.63439328, -0.09801714, 0.47139674, 0.88192126, 0.99518473, 0.77301045, 0.29028468, -0.29028468, -0.77301045, -0.99518473, -0.88192126, -0.47139674, 0.09801714, 0.63439328, 0.95694034],
        [0.94154407, 0.51410274, -0.14673047, -0.74095113, -0.99879546, -0.80320753, -0.24298018, 0.42755509, 0.90398929, 0.97003125, 0.5956993, -0.04906767, -0.67155895, -0.98917651, -0.85772861, -0.33688985, 0.33688985, 0.85772861, 0.98917651, 0.67155895, 0.04906767, -0.5956993, -0.97003125, -0.90398929, -0.42755509, 0.24298018, 0.80320753, 0.99879546, 0.74095113, 0.14673047, -0.51410274, -0.94154407],
        [0.92387953, 0.38268343, -0.38268343, -0.92387953, -0.92387953, -0.38268343, 0.38268343, 0.92387953, 0.92387953, 0.38268343, -0.38268343, -0.92387953, -0.92387953, -0.38268343, 0.38268343, 0.92387953, 0.92387953, 0.38268343, -0.38268343, -0.92387953, -0.92387953, -0.38268343, 0.38268343, 0.92387953, 0.92387953, 0.38268343, -0.38268343, -0.92387953, -0.92387953, -0.38268343, 0.38268343, 0.92387953],
        [0.90398929, 0.24298018, -0.5956993, -0.99879546, -0.67155895, 0.14673047, 0.85772861, 0.94154407, 0.33688985, -0.51410274, -0.98917651, -0.74095113, 0.04906767, 0.80320753, 0.97003125, 0.42755509, -0.42755509, -0.97003125, -0.80320753, -0.04906767, 0.74095113, 0.98917651, 0.51410274, -0.33688985, -0.94154407, -0.85772861, -0.14673047, 0.67155895, 0.99879546, 0.5956993, -0.24298018, -0.90398929],
        [0.88192126, 0.09801714, -0.77301045, -0.95694034, -0.29028468, 0.63439328, 0.99518473, 0.47139674, -0.47139674, -0.99518473, -0.63439328, 0.29028468, 0.95694034, 0.77301045, -0.09801714, -0.88192126, -0.88192126, -0.09801714, 0.77301045, 0.95694034, 0.29028468, -0.63439328, -0.99518473, -0.47139674, 0.47139674, 0.99518473, 0.63439328, -0.29028468, -0.95694034, -0.77301045, 0.09801714, 0.88192126],
    ];

    public function getAlgorithmName(): string
    {
        return self::ALGORITHM_NAME;
    }

    protected function getImageSizeForBits(int $bits): array
    {
        if (! isset(self::DCT_COEFFICIENTS[$bits])) {
            throw new \InvalidArgumentException("Unsupported bit size: $bits");
        }

        $size = self::DCT_COEFFICIENTS[$bits]['size'];

        return ['width' => $size, 'height' => $size];
    }

    public function hashFromVipsImage(VipsImage $image, int $bits = 64): HashValue
    {
        $image = $this->convertToGrayscale($image);

        $config = self::DCT_COEFFICIENTS[$bits];
        $size = $config['size'];
        $matrixSize = $config['matrix_size'];

        $pixels = $this->extractPixelsAs2DArray($image, $size, $size);
        $dctMatrix = $this->applyDCT($pixels, $size, $matrixSize);
        $diagonal = $this->extractDiagonal($dctMatrix, $matrixSize);

        $hashValue = $this->generateHash($diagonal, $bits);

        return new HashValue($hashValue, $bits, $this->getAlgorithmName());
    }


    private function applyDCT(array $pixels, int $size, int $matrixSize): array
    {
        $rows = [];
        for ($y = 0; $y < $size; $y++) {
            $rows[$y] = $this->calculateDCT($pixels[$y], $size, $matrixSize);
        }

        $matrix = [];
        $rowMatrixSize = $matrixSize;

        for ($x = 0; $x < $matrixSize; $x++) {
            $col = [];
            for ($y = 0; $y < $size; $y++) {
                $col[$y] = $rows[$y][$x];
            }
            $matrix[$x] = $this->calculateDCT($col, $size, $rowMatrixSize);
            $rowMatrixSize--;
        }

        return $matrix;
    }

    private function calculateDCT(array $vector, int $size, int $partialSize): array
    {
        $transformed = [];

        // For 64-bit, use pre-computed DCT matrix
        if ($size === 32) {
            for ($i = 0; $i < $partialSize; $i++) {
                $sum = 0;
                for ($j = 0; $j < $size; $j++) {
                    $sum += $vector[$j] * self::DCT_11_32[$i][$j];
                }
                $sum *= self::SIZE_SQRT;
                if ($i === 0) {
                    $sum *= 0.70710678118655;
                }
                $transformed[$i] = $sum;
            }
        } else {
            // Generate DCT coefficients dynamically for other sizes
            for ($i = 0; $i < $partialSize; $i++) {
                $sum = 0;
                for ($j = 0; $j < $size; $j++) {
                    $coefficient = cos(M_PI * $i * (2 * $j + 1) / (2 * $size));
                    $sum += $vector[$j] * $coefficient;
                }
                $sum *= sqrt(2.0 / $size);
                if ($i === 0) {
                    $sum *= 0.70710678118655;
                }
                $transformed[$i] = $sum;
            }
        }

        return $transformed;
    }

    private function extractDiagonal(array $matrix, int $size): array
    {
        $result = [];
        $mode = 0;
        $lower = 0;
        $max = (int) (ceil((($size * $size) / 2) + ($size * 0.5)));

        for ($t = 0; $t < (2 * $size - 1); $t++) {
            $t1 = $t;
            if ($t1 >= $size) {
                $mode++;
                $t1 = $size - 1;
                $lower++;
            } else {
                $lower = 0;
            }

            for ($i = $t1; $i >= $lower; $i--) {
                if (count($result) >= $max) {
                    return $result;
                }
                if (($t1 + $mode) % 2 === 0) {
                    $result[] = $matrix[$i][$t1 + $lower - $i];
                } else {
                    $result[] = $matrix[$t1 + $lower - $i][$i];
                }
            }
        }

        return $result;
    }

    private function generateHash(array $diagonal, int $bits): int
    {
        $pixels = array_slice($diagonal, 1, $bits);
        $average = array_sum($pixels) / count($pixels);

        $hash = 0;
        for ($i = 0; $i < $bits; $i++) {
            if ($i < count($pixels) && $pixels[$i] > $average) {
                $hash |= (1 << ($bits - 1 - $i));
            }
        }

        return $hash;
    }
}
